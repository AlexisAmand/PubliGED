import * as go from '../../../release/go';
export declare class Floorplan extends go.Diagram {
    private _palettes;
    private _pointNodes;
    private _dimensionLinks;
    private _angleNodes;
    constructor(div: HTMLDivElement | string);
    palettes: Array<go.Palette>;
    pointNodes: go.Set<go.Node>;
    dimensionLinks: go.Set<go.Link>;
    angleNodes: go.Set<go.Node>;
    convertPixelsToUnits(num: number): number;
    convertUnitsToPixels(num: number): number;
    protected getUnitsAbbreviation(units: string): string;
    convertUnits(oldUnits: string, newUnits: string, num: number): number;
    makeDefaultFurniturePaletteNodeData(): Array<any>;
    makeDefaultWallpartsPaletteNodeData(): Array<any>;
    enableWallBuilding(): void;
    enableDividerBuilding(): void;
    disableWallBuilding(): void;
    checkboxChanged(checkboxId: string): void;
    changeUnits(form: HTMLFormElement): void;
    changeUnitsConversionFactor(unitsConversionFactorInput: HTMLInputElement, gridSizeInput?: HTMLInputElement): void;
    changeGridSize(gridSizeInput: HTMLInputElement): void;
    private getCounterClockwiseWallSide;
    getLinesIntersection(a1: go.Point, a2: go.Point, b1: go.Point, b2: go.Point): go.Point | null;
    updateAllRoomBoundaries(changedWalls: go.Set<go.Group>): void;
    maybeAddRoomNode(pt: go.Point, floorImage: string, roomToUpdate?: go.Node | null): boolean;
    getRoomWalls(pt: go.Point): Array<any> | null;
    makePolygonFromRoomBoundaries(path: Array<any>): go.List<go.Point> | null;
    sortWallsClockwise(a: go.Group, b: go.Group): number;
    sortWallsClockwiseWithSetStartWall(walls: go.List<go.Group>, wall: go.Group): go.List<go.Group>;
    addInternalWallsToRoom(roomOuterBoundaryPts: go.List<go.Point>, roomOuterBoundaryPath: Array<any>): Array<any>;
    getClockwiseWallEndpoint(w: go.Group, side: number): go.Point | null;
    findRoomHoles(roomBoundaryWalls: Array<any>, pt: go.Point): Array<Array<any>>;
    getPathPts(path: Array<any>): go.List<go.Point>;
    getPolygonArea(vs: Array<go.Point>): number;
    getRoomArea(r: go.Node): number;
    isPointInWall(w: go.Group, p: go.Point): boolean;
    isPointInRoom(r: go.Node, p: go.Point): boolean;
    isPointInPolygon(vs: Array<go.Point>, point: go.Point): boolean;
    updateWall(wall: go.Group): void;
    updateRoom(room: go.Node): void;
    private getAdjustedPoint;
    buildDimensionLink(wall: go.Group, index: number, point1: go.Point, point2: go.Point, angle: number, wallOffset: number, soloWallFlag: boolean, floorplan: Floorplan, miteringSide: number, opacity?: number, stroke?: string, strokeWidth?: number): void;
    updateWallDimensions(wallsToDisplayFor?: go.Set<go.Group>): void;
    rotateAndTranslatePoint(pt: go.Point, angle: number, distance: number): go.Point;
    getWallsIntersection(w1: go.Group, w2: go.Group): go.Point | null;
    getSegmentsIntersection(p1: go.Point, p2: go.Point, p3: go.Point, p4: go.Point): go.Point | null;
    updateWallAngles(): void;
    findClosestLocOnWall(wall: go.Group, part: go.Part): go.Point | null;
}
